# 开发记录

## V0.1

1. 首先将场景平移使坐标都为非负数，然后将场景切分为20x20x20的切片，对每个切片单独编码
2. 对每个切片，首先合并重复点（浮点==）
3. 进行八叉树分裂，当某个节点内仅有一个点且该点足够接近节点原点时（这里取各坐标轴0.1范围内），用节点近似代表该点，否则继续分裂直到分裂上限，此时截断

## issues

1. 没有颜色
2. 这里采用了固定的切片，这样分出来的一个单元会是小数大小，我觉得可能将它做个固定大小的切片，根据场景切N份这样可能更好，还可以整数化
3. 这里合并重复点的条件很严格，不过其实也可以加一个参数控制合并精度，也就是在切片内进行下采样（不过如果是整数化规则点云似乎没啥用）
4. 分裂深度这里是写的定值，不过可能做一个自适应的算法，对于每个切片单独计算所需深度
5. 使用了节点原点作为重建参考，分辨率较低时场景会向原点偏移（不过如果是整数化点云这个又是最合适的）
6. 是否可以使用面片对切片内的点进行拟合？在八叉树和面片之间自适应切换？相邻面片是否可以合并？（不过这样又需要额外表示各切片的位置了）
7. 关于颜色，可以直接附加在点的数据上，不过可能压缩率就不太行，这里我有个从图像编码算法得到的想法：使用一个基本块（比如8x8）（使用某个中层节点？），按照颜色插值在里面填充颜色，然后使用空域预测或DCT之类的进行处理，再根据需要的质量加入量化，在最终显示时只显示几何点占有的位置的颜色（可能还需要环路滤波之类的）
8. 上面的颜色处理需要整数化点云，可以通过足够的采样实现？
